#!/usr/bin/env python3

import fileinput
from itertools import combinations, permutations

from z3 import Implies, Int, Optimize, Or


class IDPool(object):

    def __init__(self):
        '''Simple and minimal data structure that provides functionality
        similar to PySAT's IDPool class.'''
        self.direct = dict()
        self.reverse = list()
    
    def id(self, obj):
        '''Inserts obj into IDPool if it does not already exist. Returns the
        integer ID associated to obj.'''
        if obj not in self.direct:
            self.direct[obj] = len(self.reverse) + 1
            self.reverse.append(obj)
        return self.direct[obj]
    
    def obj(self, id):
        '''Get the object associated to id. Raises IndexError if id is not
        attributed to an object in IDPool.'''
        return self.reverse[id - 1]        


if __name__ == '__main__':
    varpool = IDPool()
    opt = Optimize()

    with fileinput.input() as sms:
        # Number of tasks, parameters and dependencies
        n = int(sms.readline().strip('\n'))
        pars = dict.fromkeys(range(1, n + 1))
        deps = dict.fromkeys(range(1, n + 1))

        for l in range(1, n + 1):
            # Current task info
            task = list(map(int, sms.readline().split()))

            # Format: (r, p, d, k, list of fragments)
            pars[l] = tuple(task[:4] + [task[4:]])
        
        for l in range(1, n + 1):
            # Ignore first digit, correspondent to the number of dependencies
            deps[l] = list(map(int, sms.readline().split()[1:]))

    # Fragment generating function
    domain = lambda: ((l, i)
        for l in range(1, n + 1)
        for i in range(1, pars[l][3] + 1))
    
    # Timing functions
    est = lambda l, i: pars[l][0] + sum(pars[l][4][:i - 1])
    lct = lambda l, i: pars[l][2] - sum(pars[l][4][i:])

    # C1: first fragment of every task must start after ready time
    for l in range(1, n + 1):
        opt.add(Int(varpool.id(('s', l, 1))) >= pars[l][0])
    
    # C2: sequential execution of fragments
    for l in range(1, n + 1):
        for i in range(1, pars[l][3]):
            # Remark: pars[l][4][i - 1] is the execution time of fragment (l, i)
            opt.add(Int(varpool.id(('s', l, i + 1))) >= Int(varpool.id(('s', \
                l, i))) + pars[l][4][i - 1])
    
    # C3: no fragment overlapping
    for ((l, i), (k, j)) in combinations(domain(), 2):
        if (k != l and k not in deps[l] and l not in deps[k] and
            est(k, j) < lct(l, i) and est(l, i) < lct(k, j)):
            opt.add(Or(Int(varpool.id(('s', k, j))) >= Int(varpool.id(('s', \
                l, i))) + pars[l][4][i - 1], Int(varpool.id(('s', l, i))) >= \
                Int(varpool.id(('s', k, j))) + pars[k][4][j - 1]))

    # C4: if task l depends on task k, l must start after k
    # for (l, k) in permutations(range(1, n + 1), 2):
    #     if l in deps[k]:
    #         opt.add(Or(Int(varpool.id(('s', l, 1))) >= Int(varpool.id(('s', \
    #             k, pars[k][3]))) + pars[k][4][-1], Implies(Int(varpool.id(('s', \
    #             k, pars[k][3]))) + pars[k][4][-1] > pars[k][2], Int(varpool.id( \
    #             ('s', l, 1))) == float('inf'))))
    
    # C5: each task must be completed by its deadline
    for l in range(1, n + 1):
        opt.add_soft(Int(varpool.id(('s', l, pars[l][3]))) + pars[l][4][-1] <= \
            pars[l][2])
    
    # Find a solution
    opt.check()
    model = opt.model()

    # Auxiliary variables
    scheduled = list()
    schedule = dict()

    # Solution interpretation
    for l in range(1, n + 1):
        if (model.eval(Int(varpool.id(('s', l, pars[l][3]))) + pars[l][4][-1] <= \
            pars[l][2])):
            scheduled.append(l)
            schedule[f'{l}'] = [model.eval(Int(varpool.id(('s', l, i)))).as_string()
                for i in range(1, pars[l][3] + 1)]
    
    # Generate output
    output = f'{len(scheduled)}\n'
    for (l, t) in schedule.items():
        output += f'{l} ' + ' '.join(t) + '\n'

    # Print output to stdout
    print(output.rstrip('\n'))
